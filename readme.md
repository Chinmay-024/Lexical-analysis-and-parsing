# Custom Programming Language Parser

This project consists of a lexer (lexical analyzer) and parser for a custom programming language. The lexer and parser are implemented using the Lex (lexer generator) and Bison (parser generator) tools. This README provides an in-depth overview of the project, including how to use it, a breakdown of the lexer and parser, and sample input and output.

## Project Structure

The project is divided into two main components: the lexer and the parser.

### Lexer (lex.l)

- The lexer is defined in the `lex.l` file.
- It recognizes and tokenizes input source code into meaningful tokens.
- Tokens include keywords (e.g., `if`, `while`, `return`), identifiers (e.g., variable names), constants (e.g., integers, floats), operators (e.g., `+`, `-`, `*`), and other language-specific symbols.
- The lexer generates tokens that are consumed by the parser.

### Parser (parser.y)

- The parser is defined in the `parser.y` file.
- It parses the tokens generated by the lexer according to the grammar rules defined in the file.
- The parser builds an abstract syntax tree (AST) that represents the structure of the input code.
- The grammar rules define the syntax of the custom programming language, including statements, expressions, declarations, and control structures.
- The parser generates a parse tree and performs semantic analysis.

## How to Use

To use the lexer and parser for your custom programming language:

1. Ensure you have Lex and Bison installed on your system.

2. Place your custom language source code in a file named "input.txt" in the project directory.

3. Compile the lexer and parser:

   ```bash
   lex lex.l
   yacc -d parser.y
   gcc lex.yy.c y.tab.c -o custom_parser -ll
   ```

4. Run the lexer and parser:

   ```bash
   ./custom_parser
   ```

5. The parser will process the input code, tokenize it, build a parse tree, and perform semantic analysis. If any syntax errors are encountered, error messages will be displayed.

6. If parsing is successful, the parser will print "Successfully parsed!" to indicate that the input code adheres to the defined grammar.

## Supported Language Features

The custom programming language supported by this parser includes the following features:

- Keywords such as `if`, `while`, `return`, `def`, `fun`, etc.
- Variables and variable declarations.
- Arithmetic and logical expressions.
- Control structures like `if` statements and `while` loops.
- Function definitions and calls.
- Basic data types (integers, floats, strings).
- Error handling for syntax errors.

## Debugging

Debugging information can be enabled by setting the `YYDEBUG` flag in the `parser.y` file to a non-zero value. This will produce additional output during parsing to help trace the parser's execution.

```c
#define YYDEBUG 1
```

## Error Handling

The parser includes error handling using the `yyerror` function. When a syntax error is encountered during parsing, an error message is displayed, including the type of error and the line number where it occurred.

## Sample Input and Output

### Sample Input (input.txt)

```custom_language
// global
//    a := a+2
// end
global
    fun hello -> null
        a := 2
    end
end
```

### Sample Output

```
Successfully parsed!
```

### Sample Input (input.txt)

```custom_language
global
    fun hello -> null
        a = a+2
    end
end
```

### Sample Output

```
syntax error in line no : 3
```

## Conclusion

This project provides a foundation for building a parser for a custom programming language. You can extend and modify the grammar rules and language features to suit your specific needs. The lexer and parser can be integrated into a compiler or interpreter for your language.
